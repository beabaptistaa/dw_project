{"ast":null,"code":"/** Keeps track of raw listeners added to the base elements to avoid duplication */\nconst ledger = new WeakMap();\nfunction editLedger(wanted, baseElement, callback, setup) {\n  var _a, _b;\n  if (!wanted && !ledger.has(baseElement)) {\n    return false;\n  }\n  const elementMap = (_a = ledger.get(baseElement)) !== null && _a !== void 0 ? _a : new WeakMap();\n  ledger.set(baseElement, elementMap);\n  if (!wanted && !ledger.has(baseElement)) {\n    return false;\n  }\n  const setups = (_b = elementMap.get(callback)) !== null && _b !== void 0 ? _b : new Set();\n  elementMap.set(callback, setups);\n  const existed = setups.has(setup);\n  if (wanted) {\n    setups.add(setup);\n  } else {\n    setups.delete(setup);\n  }\n  return existed && wanted;\n}\nfunction isEventTarget(elements) {\n  return typeof elements.addEventListener === 'function';\n}\nfunction safeClosest(event, selector) {\n  let target = event.target;\n  if (target instanceof Text) {\n    target = target.parentElement;\n  }\n  if (target instanceof Element && event.currentTarget instanceof Element) {\n    // `.closest()` may match ancestors of `currentTarget` but we only need its children\n    const closest = target.closest(selector);\n    if (closest && event.currentTarget.contains(closest)) {\n      return closest;\n    }\n  }\n}\n// This type isn't exported as a declaration, so it needs to be duplicated above\nfunction delegate(base, selector, type, callback, options) {\n  // Handle Selector-based usage\n  if (typeof base === 'string') {\n    base = document.querySelectorAll(base);\n  }\n  // Handle Array-like based usage\n  if (!isEventTarget(base)) {\n    const subscriptions = Array.prototype.map.call(base, element => delegate(element, selector, type, callback, options));\n    return {\n      destroy() {\n        for (const subscription of subscriptions) {\n          subscription.destroy();\n        }\n      }\n    };\n  }\n  // `document` should never be the base, it's just an easy way to define \"global event listeners\"\n  const baseElement = base instanceof Document ? base.documentElement : base;\n  // Handle the regular Element usage\n  const capture = Boolean(typeof options === 'object' ? options.capture : options);\n  const listenerFn = event => {\n    const delegateTarget = safeClosest(event, selector);\n    if (delegateTarget) {\n      event.delegateTarget = delegateTarget;\n      callback.call(baseElement, event);\n    }\n  };\n  // Drop unsupported `once` option https://github.com/fregante/delegate-it/pull/28#discussion_r863467939\n  if (typeof options === 'object') {\n    delete options.once;\n  }\n  const setup = JSON.stringify({\n    selector,\n    type,\n    capture\n  });\n  const isAlreadyListening = editLedger(true, baseElement, callback, setup);\n  const delegateSubscription = {\n    destroy() {\n      baseElement.removeEventListener(type, listenerFn, options);\n      editLedger(false, baseElement, callback, setup);\n    }\n  };\n  if (!isAlreadyListening) {\n    baseElement.addEventListener(type, listenerFn, options);\n  }\n  return delegateSubscription;\n}\nexport default delegate;","map":{"version":3,"names":["ledger","WeakMap","editLedger","wanted","baseElement","callback","setup","_a","_b","has","elementMap","get","set","setups","Set","existed","add","delete","isEventTarget","elements","addEventListener","safeClosest","event","selector","target","Text","parentElement","Element","currentTarget","closest","contains","delegate","base","type","options","document","querySelectorAll","subscriptions","Array","prototype","map","call","element","destroy","subscription","Document","documentElement","capture","Boolean","listenerFn","delegateTarget","once","JSON","stringify","isAlreadyListening","delegateSubscription","removeEventListener"],"sources":["/Users/beatrizbaptista/Desktop/mestrado/DW/projeto/code/node_modules/delegate-it/index.js"],"sourcesContent":["/** Keeps track of raw listeners added to the base elements to avoid duplication */\nconst ledger = new WeakMap();\nfunction editLedger(wanted, baseElement, callback, setup) {\n    var _a, _b;\n    if (!wanted && !ledger.has(baseElement)) {\n        return false;\n    }\n    const elementMap = (_a = ledger.get(baseElement)) !== null && _a !== void 0 ? _a : new WeakMap();\n    ledger.set(baseElement, elementMap);\n    if (!wanted && !ledger.has(baseElement)) {\n        return false;\n    }\n    const setups = (_b = elementMap.get(callback)) !== null && _b !== void 0 ? _b : new Set();\n    elementMap.set(callback, setups);\n    const existed = setups.has(setup);\n    if (wanted) {\n        setups.add(setup);\n    }\n    else {\n        setups.delete(setup);\n    }\n    return existed && wanted;\n}\nfunction isEventTarget(elements) {\n    return typeof elements.addEventListener === 'function';\n}\nfunction safeClosest(event, selector) {\n    let target = event.target;\n    if (target instanceof Text) {\n        target = target.parentElement;\n    }\n    if (target instanceof Element && event.currentTarget instanceof Element) {\n        // `.closest()` may match ancestors of `currentTarget` but we only need its children\n        const closest = target.closest(selector);\n        if (closest && event.currentTarget.contains(closest)) {\n            return closest;\n        }\n    }\n}\n// This type isn't exported as a declaration, so it needs to be duplicated above\nfunction delegate(base, selector, type, callback, options) {\n    // Handle Selector-based usage\n    if (typeof base === 'string') {\n        base = document.querySelectorAll(base);\n    }\n    // Handle Array-like based usage\n    if (!isEventTarget(base)) {\n        const subscriptions = Array.prototype.map.call(base, (element) => delegate(element, selector, type, callback, options));\n        return {\n            destroy() {\n                for (const subscription of subscriptions) {\n                    subscription.destroy();\n                }\n            },\n        };\n    }\n    // `document` should never be the base, it's just an easy way to define \"global event listeners\"\n    const baseElement = base instanceof Document ? base.documentElement : base;\n    // Handle the regular Element usage\n    const capture = Boolean(typeof options === 'object' ? options.capture : options);\n    const listenerFn = (event) => {\n        const delegateTarget = safeClosest(event, selector);\n        if (delegateTarget) {\n            event.delegateTarget = delegateTarget;\n            callback.call(baseElement, event);\n        }\n    };\n    // Drop unsupported `once` option https://github.com/fregante/delegate-it/pull/28#discussion_r863467939\n    if (typeof options === 'object') {\n        delete options.once;\n    }\n    const setup = JSON.stringify({ selector, type, capture });\n    const isAlreadyListening = editLedger(true, baseElement, callback, setup);\n    const delegateSubscription = {\n        destroy() {\n            baseElement.removeEventListener(type, listenerFn, options);\n            editLedger(false, baseElement, callback, setup);\n        },\n    };\n    if (!isAlreadyListening) {\n        baseElement.addEventListener(type, listenerFn, options);\n    }\n    return delegateSubscription;\n}\nexport default delegate;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}